{
  "version": 3,
  "sources": ["src/environments/environment.dev.ts", "src/app/core/auth/auth.utils.ts", "src/app/core/auth/auth.service.ts"],
  "sourcesContent": ["export const environment = {\n    production: false,\n    apiUrl: 'https://api-test.ornafish.com'\n  };", "// -----------------------------------------------------------------------------------------------------\n// @ AUTH UTILITIES\n//\n// Methods are derivations of the Auth0 Angular-JWT helper service methods\n// https://github.com/auth0/angular2-jwt\n// -----------------------------------------------------------------------------------------------------\n\nexport class AuthUtils {\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Is token expired?\n     *\n     * @param token\n     * @param offsetSeconds\n     */\n    static isTokenExpired(token: string, offsetSeconds?: number): boolean {\n        // Return if there is no token\n        if (!token || token === '') {\n            return true;\n        }\n\n        // Get the expiration date\n        const date = this._getTokenExpirationDate(token);\n\n        offsetSeconds = offsetSeconds || 0;\n\n        if (date === null) {\n            return true;\n        }\n\n        // Check if the token is expired\n        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Private methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Base64 decoder\n     * Credits: https://github.com/atk\n     *\n     * @param str\n     * @private\n     */\n    private static _b64decode(str: string): string {\n        const chars =\n            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n        let output = '';\n\n        str = String(str).replace(/=+$/, '');\n\n        if (str.length % 4 === 1) {\n            throw new Error(\n                \"'atob' failed: The string to be decoded is not correctly encoded.\"\n            );\n        }\n\n        /* eslint-disable */\n        for (\n            // initialize result and counters\n            let bc = 0, bs: any, buffer: any, idx = 0;\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4)\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n                : 0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n        /* eslint-enable */\n\n        return output;\n    }\n\n    /**\n     * Base64 unicode decoder\n     *\n     * @param str\n     * @private\n     */\n    private static _b64DecodeUnicode(str: any): string {\n        return decodeURIComponent(\n            Array.prototype.map\n                .call(\n                    this._b64decode(str),\n                    (c: any) =>\n                        '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n                )\n                .join('')\n        );\n    }\n\n    /**\n     * URL Base 64 decoder\n     *\n     * @param str\n     * @private\n     */\n    private static _urlBase64Decode(str: string): string {\n        let output = str.replace(/-/g, '+').replace(/_/g, '/');\n        switch (output.length % 4) {\n            case 0: {\n                break;\n            }\n            case 2: {\n                output += '==';\n                break;\n            }\n            case 3: {\n                output += '=';\n                break;\n            }\n            default: {\n                throw Error('Illegal base64url string!');\n            }\n        }\n        return this._b64DecodeUnicode(output);\n    }\n\n    /**\n     * Decode token\n     *\n     * @param token\n     * @private\n     */\n    private static _decodeToken(token: string): any {\n        // Return if there is no token\n        if (!token) {\n            return null;\n        }\n\n        // Split the token\n        const parts = token.split('.');\n\n        if (parts.length !== 3) {\n            throw new Error(\n                \"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\"\n            );\n        }\n\n        // Decode the token using the Base64 decoder\n        const decoded = this._urlBase64Decode(parts[1]);\n\n        if (!decoded) {\n            throw new Error('Cannot decode the token.');\n        }\n\n        return JSON.parse(decoded);\n    }\n\n    /**\n     * Get token expiration date\n     *\n     * @param token\n     * @private\n     */\n    private static _getTokenExpirationDate(token: string): Date | null {\n        // Get the decoded token\n        const decodedToken = this._decodeToken(token);\n\n        // Return if the decodedToken doesn't have an 'exp' field\n        if (!decodedToken.hasOwnProperty('exp')) {\n            return null;\n        }\n\n        // Convert the expiration date\n        const date = new Date(0);\n        date.setUTCSeconds(decodedToken.exp);\n\n        return date;\n    }\n}\n", "import { HttpClient } from '@angular/common/http';\nimport { inject, Injectable } from '@angular/core';\nimport { AuthUtils } from 'app/core/auth/auth.utils';\nimport { UserService } from 'app/core/user/user.service';\nimport { map, catchError, Observable, of, switchMap, throwError } from 'rxjs';\nimport { environment } from 'environments/environment';\n\n\n@Injectable({ providedIn: 'root' })\nexport class AuthService {\n    private _authenticated: boolean = false;\n    private _httpClient = inject(HttpClient);\n    private _userService = inject(UserService);\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Accessors\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Setter & getter for access token\n     */\n    set accessToken(token: string) {\n        localStorage.setItem('accessToken', token);\n    }\n\n    get accessToken(): string {\n        return localStorage.getItem('accessToken') ?? '';\n    }\n\n    // -----------------------------------------------------------------------------------------------------\n    // @ Public methods\n    // -----------------------------------------------------------------------------------------------------\n\n    /**\n     * Forgot password\n     *\n     * @param email\n     */\n    forgotPassword(email: string): Observable<any> {\n        return this._httpClient.post('api/auth/forgot-password', email);\n    }\n\n    /**\n     * Reset password\n     *\n     * @param password\n     */\n    resetPassword(password: string): Observable<any> {\n        return this._httpClient.post('api/auth/reset-password', password);\n    }\n\n    /**\n     * Sign in\n     *\n     * @param credentials\n     */\n    signIn(credentials: { email: string; password: string }): Observable<any> {\n        // Throw error, if the user is already logged in\n        if (this._authenticated) {\n            return throwError(() => new Error('User is already logged in.'));\n        }\n    \n        return this._httpClient.post(`${environment.apiUrl}/api/users/login`, credentials).pipe(\n            switchMap((response: any) => {\n                // ✅ JWT opslaan\n                localStorage.setItem('accessToken', response.token);\n    \n                // ✅ authenticated zetten\n                this._authenticated = true;\n    \n                // ✅ eventueel user opslaan\n                this._userService.user = response.user || { email: credentials.email };\n    \n                return of(response);\n            })\n        );\n    }\n\n    /**\n     * Sign in using the access token\n     */\n    \n    signInUsingToken(): Observable<boolean> {\n        console.log('[AuthService] signInUsingToken() gestart met token:', this.accessToken);\n\n        return this._httpClient\n            .post(`${environment.apiUrl}/api/auth/sign-in-with-token`, {\n                accessToken: this.accessToken,\n            })\n            .pipe(\n                catchError(() => {\n                    console.warn('[AuthService] Token verificatie faalde');\n                    return of(false);\n                }),\n                switchMap((response: any) => {\n                    if (response.accessToken) {\n                        this.accessToken = response.accessToken;\n                        localStorage.setItem('accessToken', response.accessToken);\n                        console.log('[AuthService] Token vernieuwd en opgeslagen');\n                    }\n\n                    // ✅ authenticated zetten\n                    this._authenticated = true;\n\n                    // ✅ user in de service opslaan\n                    this._userService.user = response.user;\n\n                    return of(true);\n                })\n            );\n    }\n\n    /**\n     * Sign out\n     */\n    signOut(): Observable<any> {\n        // Remove the access token from the local storage\n        localStorage.removeItem('accessToken');\n\n        // Set the authenticated flag to false\n        this._authenticated = false;\n\n        // Return the observable\n        return of(true);\n    }\n\n    /**\n     * Sign up\n     *\n     * @param user\n     */\n    signUp(user: {\n        name: string;\n        email: string;\n        password: string;\n        company: string;\n    }): Observable<any> {\n        return this._httpClient.post('api/auth/sign-up', user);\n    }\n\n    /**\n     * Unlock session\n     *\n     * @param credentials\n     */\n    unlockSession(credentials: {\n        email: string;\n        password: string;\n    }): Observable<any> {\n        return this._httpClient.post('api/auth/unlock-session', credentials);\n    }\n\n    /**\n     * Check the authentication status\n     */\n    check(): Observable<boolean> {\n        console.log('[AuthService] check() gestart');\n        // Check if the user is logged in\n        if (this._authenticated) {\n            return of(true);\n        }\n\n        // Check the access token availability\n        if (!this.accessToken) {\n            const token = localStorage.getItem('accessToken');\n            console.log('[AuthService] Token uit localStorage:', token);\n            if (!token) return of(false);\n            this.accessToken = token;\n        }\n\n        // Check the access token expire date\n        if (AuthUtils.isTokenExpired(this.accessToken)) {\n            return of(false);\n        }\n\n        // If the access token exists, and it didn't expire, sign in using it\n        return this.signInUsingToken();\n    }\n}\n"],
  "mappings": "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",
  "names": ["environment", "production", "apiUrl", "AuthUtils", "isTokenExpired", "token", "offsetSeconds", "date", "_getTokenExpirationDate", "valueOf", "Date", "_b64decode", "str", "chars", "output", "String", "replace", "length", "Error", "bc", "bs", "buffer", "idx", "charAt", "fromCharCode", "indexOf", "_b64DecodeUnicode", "decodeURIComponent", "Array", "prototype", "map", "call", "c", "charCodeAt", "toString", "slice", "join", "_urlBase64Decode", "_decodeToken", "parts", "split", "decoded", "JSON", "parse", "decodedToken", "hasOwnProperty", "setUTCSeconds", "exp", "AuthService", "constructor", "_authenticated", "_httpClient", "inject", "HttpClient", "_userService", "UserService", "accessToken", "token", "localStorage", "setItem", "getItem", "forgotPassword", "email", "post", "resetPassword", "password", "signIn", "credentials", "throwError", "Error", "environment", "apiUrl", "pipe", "switchMap", "response", "user", "of", "signInUsingToken", "console", "log", "catchError", "warn", "signOut", "removeItem", "signUp", "unlockSession", "check", "AuthUtils", "isTokenExpired", "factory", "\u0275fac", "providedIn"]
}
